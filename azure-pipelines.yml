trigger:
- main

parameters:
- name: targetEnv
  type: string
  default: dev
  values:
  - dev
  - prod

- name: azureServiceConnection
  type: string
  default: Azure-Service-Connection-Sub

variables:
# DEV
- ${{ if eq(parameters.targetEnv, 'dev') }}:
  - group: variable_iScalaArchive
  - name: resourceGroupName
    value: rg-iscala-archive
  - name: logicAppName
    value: la-iscala-archive
  - name: triggerName
    value: When_HTTP_is_called
  - name: storageAccount
    value: snapshottestsa
  - name: functionAppName
    value: fa-iscala-eg-proxy-dev
  - name: eventSubscriptionName
    value: iscala-archive-egsub
  - name: rgLocation
    value: swedencentral
  - name: deadLetterStorageAccountName
    value: snapshottestsa

# PROD
- ${{ if eq(parameters.targetEnv, 'prod') }}:
  - group: variable_iScalaArchive-prod
  - name: resourceGroupName
    value: rg-iscala-archive-prod
  - name: logicAppName
    value: la-iscala-archive-prod
  - name: triggerName
    value: When_HTTP_is_called
  - name: storageAccount
    value: stiscalasnapshotprod
  - name: functionAppName
    value: fa-iscala-eg-proxy-prod
  - name: eventSubscriptionName
    value: iscala-archive-egsub-prod
  - name: rgLocation
    value: swedencentral
  - name: deadLetterStorageAccountName
    value: stiscalasnapshotprod




- name: storageAccountResourceId
  value: "/subscriptions/$(subscriptionId)/resourceGroups/$(resourceGroupName)/providers/Microsoft.Storage/storageAccounts/$(storageAccount)"


stages:
- stage: Deploy
  displayName: Deploy ${{ parameters.targetEnv }}
  jobs:
  - job: Deploy
    pool:
      name: easec-pool
    steps:
    - checkout: self


    - bash: |
        set -e
        python3 -m json.tool infra/functionapp.json > /dev/null
        python3 -m json.tool infra/connections.json > /dev/null
        python3 -m json.tool infra/workbook-forwarding.json > /dev/null

        # Logic App template
        python3 -m json.tool logicapp/logicapp.json > /dev/null

        # Logic App parameter files
        python3 -m json.tool infra/parameters/logicapp.dev.json > /dev/null
        python3 -m json.tool infra/parameters/logicapp.prod.json > /dev/null
      displayName: Validate JSON templates

    - task: AzureCLI@2
      displayName: Set subscriptionId variable
      inputs:
        azureSubscription: ${{ parameters.azureServiceConnection }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          echo "##vso[task.setvariable variable=subscriptionId]$(az account show --query id -o tsv)"

    - task: AzureCLI@2
      displayName: HARD GUARDRAILS (fail if env mismatched)
      inputs:
        azureSubscription: ${{ parameters.azureServiceConnection }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          ENV="${{ parameters.targetEnv }}"
          RG="$(resourceGroupName)"
          LA="$(logicAppName)"
          FUNC="$(functionAppName)"
          ST="$(storageAccount)"
          EG="$(eventSubscriptionName)"
          SUB="$(az account show --query id -o tsv)"

          echo "Guardrails for ENV=$ENV"
          echo "RG=$RG"
          echo "LA=$LA"
          echo "FUNC=$FUNC"
          echo "ST=$ST"
          echo "EGSUB=$EG"
          echo "SUB=$SUB"

          fail() { echo "ERROR: $*" >&2; exit 1; }

          # --- 1) Naming conventions (simple but effective) ---
          if [ "$ENV" = "dev" ]; then
            [[ "$RG"   =~ -prod$ ]] && fail "DEV run but RG looks prod: $RG"
            [[ "$LA"   =~ -prod$ ]] && fail "DEV run but LogicApp looks prod: $LA"
            [[ "$FUNC" =~ -prod$ ]] && fail "DEV run but Function looks prod: $FUNC"
            [ "$ST" = "stiscalasnapshotprod" ] && fail "DEV run but Storage is prod: $ST"
            [[ "$EG" =~ -prod$ ]] && fail "DEV run but EventSub looks prod: $EG"
          fi

          if [ "$ENV" = "prod" ]; then
            [[ "$RG"   =~ -prod$ ]] || fail "PROD run but RG not -prod: $RG"
            [[ "$LA"   =~ -prod$ ]] || fail "PROD run but LogicApp not -prod: $LA"
            [[ "$FUNC" =~ -prod$ ]] || fail "PROD run but Function not -prod: $FUNC"
            [ "$ST" = "snapshottestsa" ] && fail "PROD run but Storage is dev: $ST"
            [[ "$EG" =~ -prod$ ]] || fail "PROD run but EventSub not -prod: $EG"
          fi

          # --- 2) Ensure the Logic App exists in the intended RG ---
          az resource show -g "$RG" -n "$LA" --resource-type "Microsoft.Logic/workflows" -o none \
            || fail "Logic App $LA not found in RG $RG"

          # --- 3) (Strong check) Callback URL belongs to this Logic App ---
          TRIGGER="$(triggerName)"
          CALLBACK="$(az rest --method POST \
            --uri "https://management.azure.com/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.Logic/workflows/$LA/triggers/$TRIGGER/listCallbackUrl?api-version=2019-05-01" \
            --body '{}' --query "value" -o tsv)"

          [ -n "$CALLBACK" ] && [ "$CALLBACK" != "null" ] || fail "Could not retrieve callback URL"

          # Extract workflow GUID from callback URL: .../workflows/<GUID>/triggers/...
          CB_GUID="$(echo "$CALLBACK" | sed -n 's#.*workflows/\([^/]*\)/.*#\1#p')"
          [ -n "$CB_GUID" ] || fail "Could not parse workflow GUID from callback URL"

          # Find expected GUID from the Logic App resource id
          # Logic App resourceId contains the workflow name, but callback has GUID, so validate by asking ARM for trigger callback and parsing too:
          EXPECTED_GUID="$(az rest --method POST \
            --uri "https://management.azure.com/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.Logic/workflows/$LA/triggers/$TRIGGER/listCallbackUrl?api-version=2019-05-01" \
            --body '{}' --query "value" -o tsv \
            | sed -n 's#.*workflows/\([^/]*\)/.*#\1#p')"

          [ "$CB_GUID" = "$EXPECTED_GUID" ] || fail "Callback GUID mismatch (callback does not belong to $LA in $RG). Got=$CB_GUID Expected=$EXPECTED_GUID"

          echo "OK: Callback GUID matches Logic App in correct RG."

          # --- 4) Optional: refuse any prod callback host in dev (extra belt+suspenders) ---
          if [ "$ENV" = "dev" ]; then
            echo "$CALLBACK" | grep -qi "/workflows/${CB_GUID}/" || fail "DEV callback URL does not contain expected workflow GUID"
            echo "$CALLBACK" | grep -qi "logic.azure.com" || fail "Callback URL doesn't look like Logic Apps"
          fi

          echo "HARD GUARDRAILS PASSED âœ…"

    - task: AzureResourceManagerTemplateDeployment@3
      displayName: Deploy Connections
      inputs:
        azureResourceManagerConnection: ${{ parameters.azureServiceConnection }}
        deploymentScope: Resource Group
        resourceGroupName: $(resourceGroupName)
        location: $(rgLocation)
        csmFile: infra/connections.json
        csmParametersFile: infra/parameters/connections.${{ parameters.targetEnv }}.json
        deploymentMode: Incremental

    - task: AzureResourceManagerTemplateDeployment@3
      displayName: Deploy Logic App (${{ parameters.targetEnv }})
      inputs:
        azureResourceManagerConnection: ${{ parameters.azureServiceConnection }}
        deploymentScope: Resource Group
        resourceGroupName: $(resourceGroupName)
        location: $(rgLocation)
        csmFile: logicapp/logicapp.json
        csmParametersFile: infra/parameters/logicapp.${{ parameters.targetEnv }}.json
        deploymentMode: Incremental

    - task: AzureResourceManagerTemplateDeployment@3
      displayName: Deploy Function infra
      inputs:
        azureResourceManagerConnection: ${{ parameters.azureServiceConnection }}
        deploymentScope: Resource Group
        resourceGroupName: $(resourceGroupName)
        location: $(rgLocation)
        csmFile: infra/functionapp.json
        csmParametersFile: infra/parameters/functionapp.${{ parameters.targetEnv }}.json
        deploymentMode: Incremental
        deploymentOutputs: functionOutputs

    - script: |
        echo "##vso[task.setvariable variable=functionWebhookUrl]$(functionOutputs.functionWebhookUrl.value)"
        echo "##vso[task.setvariable variable=appInsightsName]$(functionOutputs.appInsightsName.value)"
      displayName: Set outputs variables

    - task: AzureCLI@2
      displayName: Fetch Logic App callback URL -> set Function appsetting (ACTIVE)
      inputs:
        azureSubscription: ${{ parameters.azureServiceConnection }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          RG="$(resourceGroupName)"
          LA="$(logicAppName)"
          TRIGGER="$(triggerName)"
          FUNC="$(functionAppName)"
          SUB="$(az account show --query id -o tsv)"

          echo "RG=$RG  LA=$LA  FUNC=$FUNC  TRIGGER=$TRIGGER  SUB=$SUB"

          # Guardrail 1: Ensure Function App exists in this RG
          az functionapp show -g "$RG" -n "$FUNC" -o none

          # Guardrail 2: Ensure Logic App exists in this RG
          az resource show -g "$RG" -n "$LA" --resource-type Microsoft.Logic/workflows -o none

          echo "Fetching callback URL for $LA / $TRIGGER..."
          CALLBACK="$(az rest --method POST \
            --uri "https://management.azure.com/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.Logic/workflows/$LA/triggers/$TRIGGER/listCallbackUrl?api-version=2019-05-01" \
            --body '{}' --query "value" -o tsv)"

          if [ -z "$CALLBACK" ] || [ "$CALLBACK" = "null" ]; then
            echo "ERROR: Could not retrieve callback URL."
            exit 1
          fi

          echo "Callback URL (sig redacted):"
          echo "$CALLBACK" | sed -E 's/(sig=)[^&]+/\1REDACTED/g'

          echo "Setting Function appsettings (ACTIVE) + clearing NEXT..."
          az functionapp config appsettings set \
            -g "$RG" -n "$FUNC" \
            --settings "LOGICAPP_CALLBACK_URL_ACTIVE=$CALLBACK" "LOGICAPP_CALLBACK_URL_NEXT=" \
            -o none

          echo "Restarting Function App..."
          az functionapp restart -g "$RG" -n "$FUNC" -o none

          echo "Verify (values redacted):"
          az functionapp config appsettings list -g "$RG" -n "$FUNC" \
            --query "[?name=='LOGICAPP_CALLBACK_URL_ACTIVE' || name=='LOGICAPP_CALLBACK_URL_NEXT'].{name:name,value:value}" -o table \
            | sed -E 's/(sig=)[^&]+/\1REDACTED/g'


    - task: ArchiveFiles@2
      displayName: Zip Function code
      inputs:
        rootFolderOrFile: functionapp
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/functionapp.zip
        replaceExistingArchive: true

    - task: AzureCLI@2
      displayName: Deploy Function package (first-deploy retry only)
      inputs:
        azureSubscription: ${{ parameters.azureServiceConnection }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          RG="$(resourceGroupName)"
          FUNC="$(functionAppName)"
          ZIP="$(Build.ArtifactStagingDirectory)/functionapp.zip"
          MARKER_NAME="ISCALA_FIRST_DEPLOY_DONE"

          echo "Checking first-deploy marker: $MARKER_NAME"
          MARKER_VAL="$(az functionapp config appsettings list -g "$RG" -n "$FUNC" \
            --query "[?name=='$MARKER_NAME'].value | [0]" -o tsv || true)"

          if [ -z "$MARKER_VAL" ] || [ "$MARKER_VAL" = "null" ]; then
            echo "First deployment detected -> enabling warmup + retries"

            # Warm up SCM (harmless)
            curl -sS "https://${FUNC}.scm.azurewebsites.net/api/settings" >/dev/null || true

            max=3
            delay=5
            for i in $(seq 1 $max); do
              echo "ZIP deploy attempt $i/$max..."
              if az functionapp deployment source config-zip -g "$RG" -n "$FUNC" --src "$ZIP" -o none; then
                echo "ZIP deploy accepted."
                break
              fi

              if [ $i -eq $max ]; then
                echo "ERROR: ZIP deploy failed after $max attempts."
                echo "Tip: az webapp log deployment show -n $FUNC -g $RG -o jsonc"
                exit 1
              fi

              echo "Retrying in ${delay}s..."
              sleep "$delay"
              delay=$((delay * 2))
            done

            echo "Restarting Function App..."
            az functionapp restart -g "$RG" -n "$FUNC" -o none

            echo "Setting marker so retries only happen once..."
            az functionapp config appsettings set -g "$RG" -n "$FUNC" \
              --settings "$MARKER_NAME=true" -o none

          else
            echo "Not first deployment (marker=$MARKER_VAL) -> single deploy"
            az functionapp deployment source config-zip -g "$RG" -n "$FUNC" --src "$ZIP" -o none
            az functionapp restart -g "$RG" -n "$FUNC" -o none
          fi

    - task: AzureResourceManagerTemplateDeployment@3
      displayName: Ensure dead-letter container exists
      inputs:
        azureResourceManagerConnection: ${{ parameters.azureServiceConnection }}
        deploymentScope: Resource Group
        resourceGroupName: $(resourceGroupName)
        location: $(rgLocation)
        csmFile: infra/deadletter-container.json
        overrideParameters: >
          -storageAccountName "$(deadLetterStorageAccountName)"
          -containerName "eventgrid-deadletter"
        deploymentMode: Incremental

    - task: AzureResourceManagerTemplateDeployment@3
      displayName: Deploy Event Grid subscription (dead-letter enabled)
      inputs:
        azureResourceManagerConnection: ${{ parameters.azureServiceConnection }}
        deploymentScope: Resource Group
        resourceGroupName: $(resourceGroupName)
        location: $(rgLocation)
        csmFile: infra/eventgrid-subscription.json
        overrideParameters: >
          -eventSubscriptionName "$(eventSubscriptionName)"
          -sourceResourceId "$(storageAccountResourceId)"
          -endpointUrl "$(functionWebhookUrl)"
          -deadLetterStorageAccountId "/subscriptions/$(subscriptionId)/resourceGroups/$(resourceGroupName)/providers/Microsoft.Storage/storageAccounts/$(deadLetterStorageAccountName)"
          -deadLetterContainerName "eventgrid-deadletter"
        deploymentMode: Incremental